"""
Don't let return and finally meet!
Really terrible!
"""
def return_and_finally():
    try:
        return 'from_try'
    finally:
        return 'from_finally'
        
print(return_and_finally())
"""
You will surprising find from_finally on the screen!
How can that happen!
Actually,when break, continue or return in try sentence, and exactly there is a finally sentence...
It will run finally first!
"""



"""
l thought l would see two True on the screen...
"""
print('what' * 5 is "whatwhatwhatwhatwhat")
print('what' * 6 is "whatwhatwhatwhatwhatwhat")
"""
But actually...
One True and One False
How can that happan!
eee...Because of the existance of constant folding...
a powerful technology...
constant folding in python will convert a string with less than twenty characters.
But if the string has more than two characters, python will not convert it.
Think about pyc's feeling!
"""



"""
If the first two is correct...
It seems like all the sentences below can run correctly...
"""
print('right?''')
print("right?""")
#print('''right?')
#print("""right?")
"""
But actually not!It will cause a Syntax Error.
You can use three double quotes or three single quotes to end a string.
But if the scanner first get three double quotes or single,it will try to find another.
If there is not another,it will raise a Syntax Error.Surprising?Yes?
"""



"""
Let me see...
one int, two bool...
"""
various_list = [1.5, 3, "string", True, False]
integers = 0
booleans = 0
for item in various_list:
    if isinstance(item, int):
        integers += 1
    elif isinstance(item, bool):
        booleans += 1
print(integers, booleans)
"""
what!three and zero!
How to explain this!
eee...Oh, it's because True == 1 and False == 0!
That is really confusing but reasonable...
"""



"""
You are changing the tuple all the time.How can you do this!
"""
another_tuple = ([1, 2], [3, 4], [5, 6])
another_tuple[2].append(1000)
print(another_tuple)
try:
	another_tuple[2] += [99, 999]
except Exception as e:
	print(e)
print(another_tuple)
a = [10,20]
tuple_first = (50, 60, a)
print(tuple_first)
a += [30,40]
print(tuple_first)
"""
Yeah, l am wrong...
only one error...
It seems like if there is a changeable thing like list in a tuple,you can change the list with append or extend.
But += is the combination of extend and =,so...
Oh, l understand!Extend has no error, so the tuple has been changed, and then = has an error.
That's amazing!l can change the tuple, l can not wait to show this skill to my friends!
"""



"""
Two same e?one is 7 and another is generated by as?
"""
e = 7
try:
    raise Exception()
except Exception as e:
    print(type(e))
try:
	print(e)
except Exception as e:
	print(e)
"""
What!If you try to get the e variable in the end, you will get an error!
Even if the e is covered,it must be existed!
May be you know too little about finally...
It will convert into:
except Exception as e:
    try:
        print(e)
    finally:
        del e
That's terrible!Give back my e!
"""



"""
Let me look at your trick!
Let me bet, except list_2, others is all empty!
"""
list_1 = [1, 2, 3, 4]
list_2 = [1, 2, 3, 4]
list_3 = [1, 2, 3, 4]
list_4 = [1, 2, 3, 4]

for idx, item in enumerate(list_1):
    del item

for idx, item in enumerate(list_2):
    list_2.remove(item)

for idx, item in enumerate(list_3[:]):
    list_3.remove(item)

for idx, item in enumerate(list_4):
    list_4.pop(idx)
print(list_1, list_2, list_3, list_4)
"""
You are wrong again...
actually list_2 and list_4 is [2,4]...
When you remove an item from a list,the length is changed,but the index is not changed.
That's why 1 and 3 is removed, but 2 and 4 survived...
"""



"""
==, is, id and hash?They are two different objects, l guess four False
"""
class wtf():
	def __init__(self):
		print(id(self), "init!")
	def __del__(self):
		print(id(self), "del!")
print(wtf() == wtf())
print(wtf() is wtf())
print(hash(wtf()) == hash(wtf()))
print(id(wtf()) == id(wtf()))
"""
Two False and two True?when hash and id is the same?
Ok,it depends on the method python deals with an object.
The first and second situation let python to create two objects, judge and del them.
But the third and the fourth sutuation let python to create an object, the del it, then the same as another object.
So The two objects's id is the same.You can observe the result to prove this.
"""



"""
count>0?And for x in array?Every one in the list can satisfy the if sentence.
"""
array = [1, 8, 15]
g = (x for x in array if array.count(x) > 0)
array = [2, 8, 22]
print(list(g))

array_1 = [1,2,3,4]
g1 = (x for x in array_1)
array_1 = [1,2,3,4,5]
array_2 = [1,2,3,4]
g2 = (x for x in array_2)
array_2[:] = [1,2,3,4,5]
print(list(g1), list(g2))
"""
Only 8?That's confusing!
Truly, the generator object is lazy!It do not calculate a value until you need it.
So when you use list to let the generator run,the list has changed!
Then the result is transformed.But if you change the list copy, the result can not be altered.
"""
